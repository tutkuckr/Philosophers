
/*
Your program(s) must take the following arguments:
1. number_of_philosophers
2. time_to_die
3. time_to_eat
4. time_to_sleep
5. [number_of_times_each_philosopher_must_eat]

◦ number_of_philosophers: The number of philosophers and also the number of forks.

◦ time_to_die (in milliseconds): If a philosopher has not started eating within
time_to_die milliseconds since their last meal or the start of the simulation, they die.

◦ time_to_eat (in milliseconds): The time it takes for a philosopher to eat.

During that time, they will need to hold two forks.
◦ time_to_sleep (in milliseconds): The time a philosopher will spend sleeping.

◦ number_of_times_each_philosopher_must_eat (optional argument) 
: If all philosophers have eaten at least number_of_times_each_philosopher_must_eat
times, the simulation stops. If not specified, the simulation stops when a philosopher dies.
*/

/*
memset
printf, write
malloc, free
usleep, gettimeofday
pthread_create,
pthread_detach, -> set a thread to 'auto-clean' mode.
pthread_join, -> When a thread completes its execution, it releases internal resources
pthread_mutex_init,
pthread_mutex_destroy
pthread_mutex_lock,
pthread_mutex_unlock
*/

The routine is simple: pick up both forks (think if one of them is not available)→ eat → put down forks → sleep → repeat. Trouble begins when those steps overlap in time. If every philosopher grabs the left fork first, all forks are occupied and no one can collect a second — deadlock. If one glutton keeps winning the race for forks, a neighbour may wait forever — starvation.


sources:
https://www.geeksforgeeks.org/linux-unix/mutex-lock-for-linux-thread-synchronization/

valgrind --tool=helgrind -> for philosophers

About the logs of your program:
• Any state change of a philosopher must be formatted as follows:
◦ timestamp_in_ms X has taken a fork
◦ timestamp_in_ms X is eating
◦ timestamp_in_ms X is sleeping
◦ timestamp_in_ms X is thinking
◦ timestamp_in_ms X died
Replace timestamp_in_ms with the current timestamp in milliseconds
and X with the philosopher number.
• A displayed state message should not overlap with another message.
• A message announcing a philosopher’s death must be displayed within 10 ms of
their actual death.
• Again, philosophers should avoid dying!


gettimeofday function needs:
return val:
0 -> success
-1 -> error
struct timeval *tv;

struct timeval {
	time_t      tv_sec;     /* seconds */
	suseconds_t tv_usec;    /* microseconds */
};



dedicated mutex that only guards last_meal and meals_eaten: philo->m_meal;
routine function updates:
- last_meal_time (just before/when it starts eating),
- meals_eaten (right after eating).

The monitor thread reads those fields at arbitrary times to check:
- death: now - last_meal >= time_to_die
- completion: meals_eaten >= max_eat (if used)


WHOLE STRUCTURE:
Fork mutexes → protect the physical forks (resource sharing).

Meal mutex (per philo) → protect the philo’s state (last_meal, meals_eaten) from concurrent read/write.

Print mutex → serialize printf lines.

Stop/death mutex → protect the global stop/over flag.



each philo -> a thread
create a monitor thread


///////////////////
eval:
* Check how the death of a philosopher is veriﬁed and if there is a mutex to prevent a
philosopher from dying and starting eating at the same time.

* Test 1 800 200 200. The philosopher should not eat and should die.
• Test 5 800 200 200. No philosopher should die.
• Test 5 800 200 200 7. No philosopher should die and the simulation should stop when every
philosopher has eaten at least 7 times.
• Test 4 410 200 200. No philosopher should die.
• Test 4 310 200 100. One philosopher should die.
• Test with 2 philosophers and check the diﬀerent times: a death delayed by more than 10 ms
is unacceptable.
• Test with any values of your choice to verify all the requirements. Ensure philosophers die at
the right time, that they don't steal forks, and so forth.